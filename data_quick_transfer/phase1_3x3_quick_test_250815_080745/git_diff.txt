diff --git a/LightZero/lzero/model/gat_stochastic_muzero_model.py b/LightZero/lzero/model/gat_stochastic_muzero_model.py
index 21f4adf..0b0eeda 100644
--- a/LightZero/lzero/model/gat_stochastic_muzero_model.py
+++ b/LightZero/lzero/model/gat_stochastic_muzero_model.py
@@ -705,3 +705,166 @@ class GATStochasticMuZeroModel(nn.Module):
     
     def get_reward_mean(self):
         return get_reward_mean(self)
+    
+    def load_state_dict_for_transfer(self, state_dict, source_grid_size: int, target_grid_size: int):
+        """
+        3Ã—3ã‹ã‚‰4Ã—4ã¸ã®è»¢ç§»å­¦ç¿’ã®ãŸã‚ã®ã‚«ã‚¹ã‚¿ãƒ çŠ¶æ…‹è¾æ›¸èª­ã¿è¾¼ã¿
+        
+        Args:
+            state_dict: å­¦ç¿’æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã®çŠ¶æ…‹è¾æ›¸
+            source_grid_size: ã‚½ãƒ¼ã‚¹ãƒ¢ãƒ‡ãƒ«ã®ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º (e.g., 3)
+            target_grid_size: ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ¢ãƒ‡ãƒ«ã®ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º (e.g., 4)
+        """
+        print(f"ğŸ”„ è»¢ç§»å­¦ç¿’: {source_grid_size}Ã—{source_grid_size} â†’ {target_grid_size}Ã—{target_grid_size}")
+        
+        # ç¾åœ¨ã®ãƒ¢ãƒ‡ãƒ«ã®çŠ¶æ…‹è¾æ›¸ã‚’å–å¾—
+        current_state_dict = self.state_dict()
+        
+        # GATé–¢é€£ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ç›´æ¥è»¢ç§»å¯èƒ½ï¼ˆã‚°ãƒ©ãƒ•ãƒ™ãƒ¼ã‚¹ãªã®ã§ï¼‰
+        transferable_keys = []
+        size_dependent_keys = []
+        
+        for key in state_dict.keys():
+            if any(gat_component in key for gat_component in [
+                'representation_network.gat_layers',
+                'representation_network.input_proj',
+                'representation_network.output_proj',
+                'afterstate_dynamics_network.gat_afterstate.gat_layers',
+                'afterstate_dynamics_network.gat_afterstate.input_proj',
+                'afterstate_dynamics_network.gat_afterstate.output_proj',
+                'chance_encoder.gat_chance.gat_layers',
+                'chance_encoder.gat_chance.input_proj',
+                'chance_encoder.gat_chance.output_proj',
+                'value_head',
+                'policy_head',
+                'reward_head_afterstate'
+            ]):
+                # ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã«ä¾å­˜ã—ãªã„ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
+                transferable_keys.append(key)
+            elif any(size_component in key for size_component in [
+                'chance_encoder.chance_embedding',
+                'afterstate_policy_head',
+                'state_to_grid_projection'
+            ]):
+                # ã‚µã‚¤ã‚ºã«ä¾å­˜ã™ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
+                size_dependent_keys.append(key)
+            else:
+                # ãã®ä»–ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚‚è»¢ç§»
+                transferable_keys.append(key)
+        
+        print(f"âœ… è»¢ç§»å¯èƒ½ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: {len(transferable_keys)}å€‹")
+        print(f"âš ï¸  ã‚µã‚¤ã‚ºä¾å­˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿: {len(size_dependent_keys)}å€‹")
+        
+        # è»¢ç§»å¯èƒ½ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ç›´æ¥ã‚³ãƒ”ãƒ¼
+        transferred_count = 0
+        for key in transferable_keys:
+            if key in current_state_dict and key in state_dict:
+                # ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
+                if current_state_dict[key].shape == state_dict[key].shape:
+                    current_state_dict[key] = state_dict[key]
+                    transferred_count += 1
+                else:
+                    print(f"âš ï¸  ã‚µã‚¤ã‚ºä¸ä¸€è‡´ã§ã‚¹ã‚­ãƒƒãƒ—: {key}")
+                    print(f"    ã‚½ãƒ¼ã‚¹: {state_dict[key].shape}, ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ: {current_state_dict[key].shape}")
+        
+        # ã‚µã‚¤ã‚ºä¾å­˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å‡¦ç†
+        adapted_count = 0
+        for key in size_dependent_keys:
+            if key in current_state_dict and key in state_dict:
+                adapted_count += self._adapt_size_dependent_parameter(
+                    key, state_dict[key], current_state_dict, 
+                    source_grid_size, target_grid_size
+                )
+        
+        # æ›´æ–°ã•ã‚ŒãŸçŠ¶æ…‹è¾æ›¸ã‚’èª­ã¿è¾¼ã¿
+        self.load_state_dict(current_state_dict, strict=False)
+        
+        print(f"ğŸ‰ è»¢ç§»å­¦ç¿’å®Œäº†:")
+        print(f"  - ç›´æ¥è»¢ç§»: {transferred_count}å€‹ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿")
+        print(f"  - é©å¿œè»¢ç§»: {adapted_count}å€‹ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿")
+        
+    def _adapt_size_dependent_parameter(self, key: str, source_param: torch.Tensor, 
+                                       current_state_dict: dict, source_grid_size: int, 
+                                       target_grid_size: int) -> int:
+        """
+        ã‚µã‚¤ã‚ºä¾å­˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®é©å¿œçš„è»¢ç§»
+        
+        Returns:
+            int: æˆåŠŸã—ãŸå ´åˆã¯1ã€å¤±æ•—ã—ãŸå ´åˆã¯0
+        """
+        current_param = current_state_dict[key]
+        
+        try:
+            if 'chance_embedding' in key:
+                # ãƒãƒ£ãƒ³ã‚¹åŸ‹ã‚è¾¼ã¿ã®é©å¿œ
+                source_chance_size = source_grid_size ** 2 * 2  # 3Ã—3ãªã‚‰18
+                target_chance_size = target_grid_size ** 2 * 2  # 4Ã—4ãªã‚‰32
+                
+                if source_param.shape[0] == source_chance_size and current_param.shape[0] == target_chance_size:
+                    # åŸ‹ã‚è¾¼ã¿æ¬¡å…ƒã¯åŒã˜ã¯ãšãªã®ã§ã€æ–°ã—ã„ã‚¨ãƒ³ãƒˆãƒªã¯å¹³å‡å€¤ã§åˆæœŸåŒ–
+                    embedding_dim = source_param.shape[1]
+                    new_embedding = torch.zeros(target_chance_size, embedding_dim)
+                    
+                    # æ—¢å­˜ã®éƒ¨åˆ†ã‚’ã‚³ãƒ”ãƒ¼
+                    copy_size = min(source_chance_size, target_chance_size)
+                    new_embedding[:copy_size] = source_param[:copy_size]
+                    
+                    # æ–°ã—ã„éƒ¨åˆ†ã¯æ—¢å­˜ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å¹³å‡å€¤ã§åˆæœŸåŒ–
+                    if target_chance_size > source_chance_size:
+                        mean_param = source_param.mean(dim=0, keepdim=True)
+                        new_embedding[source_chance_size:] = mean_param.expand(
+                            target_chance_size - source_chance_size, -1
+                        )
+                    
+                    current_state_dict[key] = new_embedding
+                    print(f"âœ… ãƒãƒ£ãƒ³ã‚¹åŸ‹ã‚è¾¼ã¿é©å¿œ: {source_chance_size} â†’ {target_chance_size}")
+                    return 1
+                    
+            elif 'afterstate_policy_head' in key:
+                # ã‚¢ãƒ•ã‚¿ãƒ¼çŠ¶æ…‹ãƒãƒªã‚·ãƒ¼ãƒ˜ãƒƒãƒ‰ã®é©å¿œ
+                # æœ€å¾Œã®å±¤ã®ã¿ã‚µã‚¤ã‚ºãŒç•°ãªã‚‹
+                if len(source_param.shape) == 2:  # Linearå±¤ã®é‡ã¿
+                    source_out_features = source_param.shape[0]
+                    target_out_features = current_param.shape[0]
+                    
+                    if source_out_features != target_out_features:
+                        # æ–°ã—ã„å‡ºåŠ›ã‚µã‚¤ã‚ºã«æ‹¡å¼µ
+                        new_param = torch.zeros_like(current_param)
+                        copy_size = min(source_out_features, target_out_features)
+                        new_param[:copy_size] = source_param[:copy_size]
+                        
+                        # æ–°ã—ã„éƒ¨åˆ†ã¯æ—¢å­˜ã®å¹³å‡å€¤ã§åˆæœŸåŒ–
+                        if target_out_features > source_out_features:
+                            mean_param = source_param.mean(dim=0, keepdim=True)
+                            new_param[source_out_features:] = mean_param.expand(
+                                target_out_features - source_out_features, -1
+                            )
+                        
+                        current_state_dict[key] = new_param
+                        print(f"âœ… ã‚¢ãƒ•ã‚¿ãƒ¼çŠ¶æ…‹ãƒãƒªã‚·ãƒ¼ãƒ˜ãƒƒãƒ‰é©å¿œ: {source_out_features} â†’ {target_out_features}")
+                        return 1
+                        
+                elif len(source_param.shape) == 1:  # ãƒã‚¤ã‚¢ã‚¹
+                    source_features = source_param.shape[0]
+                    target_features = current_param.shape[0]
+                    
+                    if source_features != target_features:
+                        new_param = torch.zeros_like(current_param)
+                        copy_size = min(source_features, target_features)
+                        new_param[:copy_size] = source_param[:copy_size]
+                        
+                        # æ–°ã—ã„éƒ¨åˆ†ã¯æ—¢å­˜ã®å¹³å‡å€¤ã§åˆæœŸåŒ–
+                        if target_features > source_features:
+                            mean_val = source_param.mean()
+                            new_param[source_features:] = mean_val
+                            
+                        current_state_dict[key] = new_param
+                        print(f"âœ… ã‚¢ãƒ•ã‚¿ãƒ¼çŠ¶æ…‹ãƒãƒªã‚·ãƒ¼ãƒã‚¤ã‚¢ã‚¹é©å¿œ: {source_features} â†’ {target_features}")
+                        return 1
+                        
+            print(f"âš ï¸  é©å¿œã§ãã¾ã›ã‚“ã§ã—ãŸ: {key}")
+            return 0
+            
+        except Exception as e:
+            print(f"âŒ ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é©å¿œã‚¨ãƒ©ãƒ¼ {key}: {e}")
+            return 0
diff --git a/LightZero/zoo/game_2048/config/gat_stochastic_2048_config.py b/LightZero/zoo/game_2048/config/gat_stochastic_2048_config.py
index 4a397ac..bec7cbd 100644
--- a/LightZero/zoo/game_2048/config/gat_stochastic_2048_config.py
+++ b/LightZero/zoo/game_2048/config/gat_stochastic_2048_config.py
@@ -26,7 +26,7 @@ num_of_possible_chance_tile = 2
 # GAT-specific configurations for StochasticMuZero
 # ==============================================
 # ã€é‡è¦ã€‘ä»¥ä¸‹ã®å¤‰æ•°ã‚’å¤‰æ›´ã™ã‚‹ã ã‘ã§å…¨ã¦ã®è¨­å®šãŒè‡ªå‹•èª¿æ•´ã•ã‚Œã¾ã™
-grid_size = 4  # ã‚²ãƒ¼ãƒ ã®ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º (3=3x3, 4=4x4, 5=5x5, etc.)
+grid_size = 3  # ã‚²ãƒ¼ãƒ ã®ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º (3=3x3, 4=4x4, 5=5x5, etc.)
 # ==============================================
 chance_space_size = (grid_size ** 2) * num_of_possible_chance_tile  # Automatically calculated based on grid size
 num_heads = 4